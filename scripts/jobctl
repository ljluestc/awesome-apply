#!/usr/bin/env python3
"""
JobCtl - Command Line Interface for Job Automation System
Inspired by CloudPods' climc tool
"""

import argparse
import json
import requests
import sys
import os
from datetime import datetime, timedelta
import subprocess
from typing import Dict, List, Optional
import yaml

class JobCtlConfig:
    """Configuration management for jobctl"""

    def __init__(self):
        self.config_file = os.path.expanduser('~/.jobctl.yaml')
        self.config = self.load_config()

    def load_config(self) -> Dict:
        """Load configuration from file"""
        default_config = {
            'api_endpoint': 'http://localhost:8080',
            'web_endpoint': 'http://localhost:5000',
            'timeout': 30,
            'auth': {
                'token': None,
                'username': None
            },
            'output_format': 'table'
        }

        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    file_config = yaml.safe_load(f)
                    default_config.update(file_config)
            except Exception as e:
                print(f"Warning: Failed to load config file: {e}")

        return default_config

    def save_config(self):
        """Save configuration to file"""
        try:
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
            with open(self.config_file, 'w') as f:
                yaml.dump(self.config, f)
            print(f"Configuration saved to {self.config_file}")
        except Exception as e:
            print(f"Error saving config: {e}")

class JobCtlAPI:
    """API client for job automation system"""

    def __init__(self, config: JobCtlConfig):
        self.config = config
        self.session = requests.Session()
        if config.config['auth']['token']:
            self.session.headers.update({
                'Authorization': f"Bearer {config.config['auth']['token']}"
            })

    def _request(self, method: str, endpoint: str, **kwargs) -> Dict:
        """Make API request"""
        url = f"{self.config.config['api_endpoint']}{endpoint}"

        try:
            response = self.session.request(
                method, url,
                timeout=self.config.config['timeout'],
                **kwargs
            )
            response.raise_for_status()

            if response.headers.get('content-type', '').startswith('application/json'):
                return response.json()
            else:
                return {'data': response.text}

        except requests.exceptions.RequestException as e:
            print(f"API Error: {e}")
            sys.exit(1)

    def get_jobs(self, filters: Optional[Dict] = None) -> List[Dict]:
        """Get job listings"""
        params = filters or {}
        return self._request('GET', '/api/jobs', params=params)

    def get_job_stats(self) -> Dict:
        """Get job statistics"""
        return self._request('GET', '/api/stats')

    def start_scraper(self, source: Optional[str] = None) -> Dict:
        """Start job scraper"""
        data = {'source': source} if source else {}
        return self._request('POST', '/api/scraper/start', json=data)

    def stop_scraper(self) -> Dict:
        """Stop job scraper"""
        return self._request('POST', '/api/scraper/stop')

    def get_scraper_status(self) -> Dict:
        """Get scraper status"""
        return self._request('GET', '/api/scraper/status')

    def submit_application(self, job_id: str, resume_path: Optional[str] = None) -> Dict:
        """Submit job application"""
        data = {'job_id': job_id}
        if resume_path:
            data['resume_path'] = resume_path
        return self._request('POST', '/api/applications', json=data)

    def get_applications(self) -> List[Dict]:
        """Get application history"""
        return self._request('GET', '/api/applications')

class JobCtlOutput:
    """Output formatting utilities"""

    @staticmethod
    def print_table(data: List[Dict], columns: List[str] = None):
        """Print data as a table"""
        if not data:
            print("No data found")
            return

        if not columns:
            columns = list(data[0].keys())

        # Calculate column widths
        widths = {}
        for col in columns:
            widths[col] = max(
                len(col),
                max(len(str(row.get(col, ''))) for row in data)
            )

        # Print header
        header = " | ".join(col.ljust(widths[col]) for col in columns)
        print(header)
        print("-" * len(header))

        # Print rows
        for row in data:
            line = " | ".join(str(row.get(col, '')).ljust(widths[col]) for col in columns)
            print(line)

    @staticmethod
    def print_json(data):
        """Print data as JSON"""
        print(json.dumps(data, indent=2, default=str))

    @staticmethod
    def print_yaml(data):
        """Print data as YAML"""
        print(yaml.dump(data, default_flow_style=False))

def cmd_config(args):
    """Configuration management commands"""
    config = JobCtlConfig()

    if args.set:
        key, value = args.set.split('=', 1)
        keys = key.split('.')
        current = config.config
        for k in keys[:-1]:
            if k not in current:
                current[k] = {}
            current = current[k]
        current[keys[-1]] = value
        config.save_config()

    elif args.get:
        keys = args.get.split('.')
        current = config.config
        for k in keys:
            current = current.get(k, {})
        print(current)

    else:
        JobCtlOutput.print_yaml(config.config)

def cmd_jobs(args):
    """Job listing and management commands"""
    config = JobCtlConfig()
    api = JobCtlAPI(config)

    if args.action == 'list':
        filters = {}
        if args.company:
            filters['company'] = args.company
        if args.location:
            filters['location'] = args.location
        if args.remote:
            filters['remote_friendly'] = True

        jobs = api.get_jobs(filters)

        if args.output == 'json':
            JobCtlOutput.print_json(jobs)
        elif args.output == 'yaml':
            JobCtlOutput.print_yaml(jobs)
        else:
            columns = ['id', 'title', 'company', 'location', 'posted_date']
            if isinstance(jobs, dict) and 'data' in jobs:
                jobs = jobs['data']
            JobCtlOutput.print_table(jobs, columns)

    elif args.action == 'stats':
        stats = api.get_job_stats()
        JobCtlOutput.print_json(stats)

def cmd_scraper(args):
    """Scraper management commands"""
    config = JobCtlConfig()
    api = JobCtlAPI(config)

    if args.action == 'start':
        result = api.start_scraper(args.source)
        print(f"Scraper started: {result}")

    elif args.action == 'stop':
        result = api.stop_scraper()
        print(f"Scraper stopped: {result}")

    elif args.action == 'status':
        status = api.get_scraper_status()
        JobCtlOutput.print_json(status)

def cmd_apply(args):
    """Application management commands"""
    config = JobCtlConfig()
    api = JobCtlAPI(config)

    if args.action == 'submit':
        result = api.submit_application(args.job_id, args.resume)
        print(f"Application submitted: {result}")

    elif args.action == 'list':
        applications = api.get_applications()
        if isinstance(applications, dict) and 'data' in applications:
            applications = applications['data']

        columns = ['id', 'job_id', 'status', 'applied_at']
        JobCtlOutput.print_table(applications, columns)

def cmd_k8s(args):
    """Kubernetes management commands"""
    if args.action == 'deploy':
        subprocess.run(['make', 'deploy-k8s'], check=True)
        print("Deployment completed")

    elif args.action == 'status':
        subprocess.run(['make', 'k8s-status'], check=True)

    elif args.action == 'logs':
        subprocess.run(['make', 'k8s-logs'], check=True)

    elif args.action == 'clean':
        subprocess.run(['make', 'clean-k8s'], check=True)
        print("Cleanup completed")

def cmd_dev(args):
    """Development environment commands"""
    if args.action == 'up':
        subprocess.run(['make', 'dev-up'], check=True)
        print("Development environment started")

    elif args.action == 'down':
        subprocess.run(['make', 'dev-down'], check=True)
        print("Development environment stopped")

    elif args.action == 'logs':
        subprocess.run(['make', 'dev-logs'], check=True)

    elif args.action == 'restart':
        subprocess.run(['make', 'dev-restart'], check=True)
        print("Development environment restarted")

def main():
    parser = argparse.ArgumentParser(description='JobCtl - Job Automation System CLI')
    parser.add_argument('--output', '-o', choices=['table', 'json', 'yaml'],
                       default='table', help='Output format')

    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Configuration commands
    config_parser = subparsers.add_parser('config', help='Configuration management')
    config_parser.add_argument('--set', help='Set configuration value (key=value)')
    config_parser.add_argument('--get', help='Get configuration value')
    config_parser.set_defaults(func=cmd_config)

    # Job commands
    jobs_parser = subparsers.add_parser('jobs', help='Job management')
    jobs_parser.add_argument('action', choices=['list', 'stats'])
    jobs_parser.add_argument('--company', help='Filter by company')
    jobs_parser.add_argument('--location', help='Filter by location')
    jobs_parser.add_argument('--remote', action='store_true', help='Remote jobs only')
    jobs_parser.set_defaults(func=cmd_jobs)

    # Scraper commands
    scraper_parser = subparsers.add_parser('scraper', help='Scraper management')
    scraper_parser.add_argument('action', choices=['start', 'stop', 'status'])
    scraper_parser.add_argument('--source', help='Scraper source')
    scraper_parser.set_defaults(func=cmd_scraper)

    # Application commands
    apply_parser = subparsers.add_parser('apply', help='Application management')
    apply_parser.add_argument('action', choices=['submit', 'list'])
    apply_parser.add_argument('--job-id', help='Job ID for application')
    apply_parser.add_argument('--resume', help='Resume file path')
    apply_parser.set_defaults(func=cmd_apply)

    # Kubernetes commands
    k8s_parser = subparsers.add_parser('k8s', help='Kubernetes management')
    k8s_parser.add_argument('action', choices=['deploy', 'status', 'logs', 'clean'])
    k8s_parser.set_defaults(func=cmd_k8s)

    # Development commands
    dev_parser = subparsers.add_parser('dev', help='Development environment')
    dev_parser.add_argument('action', choices=['up', 'down', 'logs', 'restart'])
    dev_parser.set_defaults(func=cmd_dev)

    args = parser.parse_args()

    if hasattr(args, 'func'):
        try:
            args.func(args)
        except KeyboardInterrupt:
            print("\nOperation cancelled by user")
            sys.exit(1)
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()