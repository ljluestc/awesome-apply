#!/usr/bin/env python3
"""
üöÄ DEPLOY CONTINUOUS JOB AUTOMATION üöÄ
======================================

This script deploys and manages your continuous job application automation system.
It orchestrates all your existing automation scripts for maximum job application efficiency.

What this system does:
‚úÖ Starts the JobRight.ai server with job scraping
‚úÖ Runs your automated job application system (10 browser tabs)
‚úÖ Monitors and restarts systems if they fail
‚úÖ Provides real-time progress monitoring
‚úÖ Runs continuously until you stop it
"""

import sys
import os
import time
import subprocess
import signal
import threading
import requests
from datetime import datetime, timedelta
from pathlib import Path

class ContinuousJobAutomation:
    """Deploys and manages continuous job application automation"""

    def __init__(self):
        self.base_dir = Path('/home/calelin/awesome-apply')
        self.python_path = '/home/calelin/awesome-apply/venv/bin/python'
        self.env = {
            'PYTHONPATH': '/home/calelin/awesome-apply/venv/lib/python3.13/site-packages:/home/calelin/awesome-apply',
            'PATH': os.environ.get('PATH', '')
        }

        self.processes = {}
        self.running = True
        self.stats = {
            'start_time': time.time(),
            'jobright_restarts': 0,
            'automation_restarts': 0,
            'total_applications': 0
        }

    def log(self, message: str, system: str = "DEPLOY"):
        """Enhanced logging"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        print(f"[{timestamp}] [{system}] {message}")

    def start_jobright_server(self):
        """Start the JobRight.ai server"""
        self.log("üöÄ Starting JobRight.ai server...")

        try:
            process = subprocess.Popen(
                [self.python_path, 'ultimate_jobright_complete.py'],
                cwd=str(self.base_dir),
                env={**os.environ, **self.env},
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            self.processes['jobright'] = {
                'process': process,
                'start_time': time.time(),
                'type': 'server'
            }

            # Wait for server to start
            self.log("‚è≥ Waiting for JobRight server to initialize...")
            time.sleep(15)

            # Check if server is running
            try:
                response = requests.get('http://localhost:5000', timeout=5)
                if response.status_code == 200:
                    self.log("‚úÖ JobRight server started successfully", "JOBRIGHT")
                    return True
                else:
                    self.log("‚ùå JobRight server not responding properly", "JOBRIGHT")
                    return False
            except:
                self.log("‚ùå JobRight server failed to start", "JOBRIGHT")
                return False

        except Exception as e:
            self.log(f"‚ùå Failed to start JobRight server: {e}", "ERROR")
            return False

    def start_automation_system(self):
        """Start the automated job application system"""
        self.log("ü§ñ Starting automated job application system...")

        try:
            process = subprocess.Popen(
                [self.python_path, 'automated_job_application_system.py'],
                cwd=str(self.base_dir),
                env={**os.environ, **self.env},
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            self.processes['automation'] = {
                'process': process,
                'start_time': time.time(),
                'type': 'automation'
            }

            # Give system time to initialize
            time.sleep(5)

            if process.poll() is None:
                self.log("‚úÖ Automation system started successfully", "AUTOMATION")
                return True
            else:
                self.log("‚ùå Automation system failed to start", "AUTOMATION")
                return False

        except Exception as e:
            self.log(f"‚ùå Failed to start automation system: {e}", "ERROR")
            return False

    def check_system_health(self):
        """Check health of running systems and restart if needed"""
        while self.running:
            try:
                time.sleep(60)  # Check every minute

                # Check JobRight server
                if 'jobright' in self.processes:
                    process_info = self.processes['jobright']
                    process = process_info['process']

                    if process.poll() is not None:  # Process has stopped
                        self.log("‚ö†Ô∏è JobRight server stopped, restarting...", "MONITOR")
                        if self.start_jobright_server():
                            self.stats['jobright_restarts'] += 1
                            self.log("‚úÖ JobRight server restarted successfully", "MONITOR")
                    else:
                        # Check if server is responding
                        try:
                            response = requests.get('http://localhost:5000', timeout=2)
                            if response.status_code != 200:
                                self.log("‚ö†Ô∏è JobRight server not responding, restarting...", "MONITOR")
                                process.terminate()
                                time.sleep(3)
                                if self.start_jobright_server():
                                    self.stats['jobright_restarts'] += 1
                        except:
                            pass

                # Check automation system
                if 'automation' in self.processes:
                    process_info = self.processes['automation']
                    process = process_info['process']

                    if process.poll() is not None:  # Process has stopped
                        self.log("‚ö†Ô∏è Automation system stopped, restarting...", "MONITOR")
                        if self.start_automation_system():
                            self.stats['automation_restarts'] += 1
                            self.log("‚úÖ Automation system restarted successfully", "MONITOR")

            except Exception as e:
                self.log(f"‚ùå Health check error: {e}", "ERROR")

    def get_application_stats(self):
        """Get current application statistics"""
        try:
            response = requests.get('http://localhost:5000/api/analytics', timeout=3)
            if response.status_code == 200:
                return response.json()
        except:
            pass
        return {}

    def monitor_progress(self):
        """Monitor and display progress"""
        while self.running:
            try:
                time.sleep(300)  # Update every 5 minutes

                runtime = (time.time() - self.stats['start_time']) / 3600
                stats = self.get_application_stats()

                self.log("=" * 70)
                self.log("üìä CONTINUOUS AUTOMATION STATUS")
                self.log("=" * 70)
                self.log(f"‚è±Ô∏è  Runtime: {runtime:.1f} hours")
                self.log(f"üöÄ JobRight restarts: {self.stats['jobright_restarts']}")
                self.log(f"ü§ñ Automation restarts: {self.stats['automation_restarts']}")

                if stats:
                    self.log(f"üìù Total applications: {stats.get('successful_applications', 0)}")
                    self.log(f"üìã Jobs in system: {stats.get('total_jobs', 0)}")
                    self.log(f"üìà Success rate: {stats.get('success_rate', 0):.1f}%")

                # Check process status
                active_processes = 0
                for name, proc_info in self.processes.items():
                    if proc_info['process'].poll() is None:
                        active_processes += 1
                        self.log(f"‚úÖ {name.upper()}: Running")
                    else:
                        self.log(f"‚ùå {name.upper()}: Stopped")

                self.log(f"üèÉ Active processes: {active_processes}/{len(self.processes)}")
                self.log("=" * 70)

            except Exception as e:
                self.log(f"‚ùå Monitor error: {e}", "ERROR")

    def deploy_automation(self):
        """Main deployment function"""
        self.log("üöÄ DEPLOYING CONTINUOUS JOB APPLICATION AUTOMATION")
        self.log("=" * 70)
        self.log("üéØ MISSION: Continuously apply to jobs until you find employment")
        self.log("‚ö° FEATURES: Multi-system orchestration with auto-restart")
        self.log("ü§ñ SYSTEMS: JobRight.ai + 10-tab automation + monitoring")
        self.log("=" * 70)

        try:
            # Start JobRight server
            if not self.start_jobright_server():
                self.log("‚ùå Failed to start JobRight server, aborting", "ERROR")
                return False

            # Start automation system
            if not self.start_automation_system():
                self.log("‚ùå Failed to start automation system, continuing anyway", "WARNING")

            # Start health monitoring
            health_thread = threading.Thread(target=self.check_system_health, daemon=True)
            health_thread.start()

            # Start progress monitoring
            monitor_thread = threading.Thread(target=self.monitor_progress, daemon=True)
            monitor_thread.start()

            self.log("üéâ ALL SYSTEMS DEPLOYED SUCCESSFULLY!")
            self.log("üåê JobRight Dashboard: http://localhost:5000")
            self.log("ü§ñ Automation: Running in 10 browser tabs")
            self.log("üìä Monitoring: Real-time health and progress tracking")
            self.log("‚å®Ô∏è  Press Ctrl+C to stop all systems")
            self.log("=" * 70)

            # Main loop
            while self.running:
                try:
                    time.sleep(3600)  # Sleep for 1 hour

                    # Hourly summary
                    runtime_hours = (time.time() - self.stats['start_time']) / 3600
                    stats = self.get_application_stats()

                    self.log("üïê HOURLY SUMMARY:")
                    self.log(f"   ‚è±Ô∏è  Runtime: {runtime_hours:.1f} hours")
                    self.log(f"   üöÄ Applications: {stats.get('successful_applications', 0)}")
                    self.log(f"   üìã Jobs available: {stats.get('total_jobs', 0)}")

                    if stats.get('successful_applications', 0) > 0:
                        self.log("   üéâ Applications are being submitted successfully!")
                    else:
                        self.log("   ‚è≥ Systems are running, applications will come...")

                except KeyboardInterrupt:
                    break
                except Exception as e:
                    self.log(f"‚ùå Main loop error: {e}", "ERROR")

            return True

        except KeyboardInterrupt:
            self.log("üõë Deployment stopped by user")
            return True
        except Exception as e:
            self.log(f"‚ùå Fatal deployment error: {e}", "ERROR")
            return False

    def stop_all_systems(self):
        """Gracefully stop all systems"""
        self.log("üõë Stopping all automation systems...")
        self.running = False

        for name, proc_info in self.processes.items():
            try:
                process = proc_info['process']
                if process.poll() is None:
                    self.log(f"üõë Stopping {name}...")
                    process.terminate()

                    try:
                        process.wait(timeout=10)
                        self.log(f"‚úÖ {name} stopped gracefully")
                    except subprocess.TimeoutExpired:
                        self.log(f"‚ö†Ô∏è Force killing {name}...")
                        process.kill()
                        process.wait()
                        self.log(f"üíÄ {name} force killed")

            except Exception as e:
                self.log(f"‚ùå Error stopping {name}: {e}", "ERROR")

        self.log("‚úÖ All systems stopped")

    def print_final_summary(self):
        """Print final deployment summary"""
        runtime_hours = (time.time() - self.stats['start_time']) / 3600
        stats = self.get_application_stats()

        self.log("=" * 70)
        self.log("üèÅ CONTINUOUS AUTOMATION DEPLOYMENT COMPLETED")
        self.log("=" * 70)
        self.log(f"‚è±Ô∏è  Total runtime: {runtime_hours:.1f} hours")
        self.log(f"üîÑ JobRight restarts: {self.stats['jobright_restarts']}")
        self.log(f"üîÑ Automation restarts: {self.stats['automation_restarts']}")

        if stats:
            applications = stats.get('successful_applications', 0)
            jobs = stats.get('total_jobs', 0)
            self.log(f"üöÄ Applications submitted: {applications}")
            self.log(f"üìã Jobs processed: {jobs}")

            if applications > 0:
                self.log("üéâ SUCCESS! Job applications have been submitted")
                self.log("üìß Check your email for responses from employers")
                self.log("üíº Keep your LinkedIn and phone available for interviews")
            else:
                self.log("‚è≥ Systems ran successfully but may need more time")
                self.log("üí° Consider running for longer periods for best results")
        else:
            self.log("‚ÑπÔ∏è Statistics not available")

        self.log("=" * 70)

def main():
    """Main deployment function"""
    automation = ContinuousJobAutomation()

    # Set up signal handlers for graceful shutdown
    def signal_handler(sig, frame):
        print("\nüõë Shutdown signal received...")
        automation.stop_all_systems()
        automation.print_final_summary()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    print("üöÄ CONTINUOUS JOB APPLICATION AUTOMATION DEPLOYMENT")
    print("=" * 70)
    print("This system will:")
    print("‚úÖ Deploy JobRight.ai server with job scraping")
    print("‚úÖ Launch 10 automated browser tabs for job applications")
    print("‚úÖ Monitor and restart systems automatically")
    print("‚úÖ Provide real-time progress updates")
    print("‚úÖ Run continuously until you stop it (Ctrl+C)")
    print("‚úÖ Apply to jobs 24/7 to maximize your chances")
    print("=" * 70)

    try:
        success = automation.deploy_automation()
        automation.stop_all_systems()
        automation.print_final_summary()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"üí• Fatal error: {e}")
        automation.stop_all_systems()
        sys.exit(1)

if __name__ == "__main__":
    main()